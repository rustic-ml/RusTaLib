//! # Trend Following Strategy for Stocks
//! 
//! A strategy that combines multiple technical indicators to identify and follow
//! market trends in stocks. It uses moving averages, momentum indicators, and
//! volatility bands to generate buy and sell signals.

use crate::indicators::{
    moving_averages::calculate_sma,
    oscillators::{calculate_macd, calculate_rsi},
    volatility::calculate_bollinger_bands,
};
use polars::prelude::*;

/// Strategy parameters for the trend following strategy
///
/// This struct contains all configurable parameters that affect how
/// the strategy identifies buy and sell signals.
#[derive(Clone)]
pub struct StrategyParams {
    /// Period for short-term Simple Moving Average (SMA)
    pub sma_short_period: usize,

    /// Period for long-term Simple Moving Average (SMA)
    pub sma_long_period: usize,

    /// Period for Relative Strength Index (RSI)
    pub rsi_period: usize,

    /// RSI level considered overbought (typically 70-80)
    pub rsi_overbought: f64,

    /// RSI level considered oversold (typically 20-30)
    pub rsi_oversold: f64,

    /// Period for Bollinger Bands calculation
    pub bb_period: usize,

    /// Standard deviation multiplier for Bollinger Bands width
    pub bb_std_dev: f64,

    /// Fast period for MACD calculation
    pub macd_fast: usize,

    /// Slow period for MACD calculation
    pub macd_slow: usize,

    /// Signal period for MACD calculation
    pub macd_signal: usize,

    /// Minimum number of buy signals required to trigger a buy
    pub min_signals_for_buy: usize,

    /// Minimum number of sell signals required to trigger a sell
    pub min_signals_for_sell: usize,
}

impl Default for StrategyParams {
    /// Creates a new `StrategyParams` instance with default values
    ///
    /// # Default values
    ///
    /// - SMA short period: 10
    /// - SMA long period: 50
    /// - RSI period: 14
    /// - RSI overbought: 70.0
    /// - RSI oversold: 30.0
    /// - Bollinger Bands period: 20
    /// - Bollinger Bands std dev: 2.0
    /// - MACD fast: 12
    /// - MACD slow: 26
    /// - MACD signal: 9
    /// - Minimum signals for buy: 2
    /// - Minimum signals for sell: 2
    fn default() -> Self {
        Self {
            sma_short_period: 10,
            sma_long_period: 50,
            rsi_period: 14,
            rsi_overbought: 70.0,
            rsi_oversold: 30.0,
            bb_period: 20,
            bb_std_dev: 2.0,
            macd_fast: 12,
            macd_slow: 26,
            macd_signal: 9,
            min_signals_for_buy: 2,
            min_signals_for_sell: 2,
        }
    }
}

/// Strategy result with signals and indicator values
///
/// This struct contains the buy/sell signals generated by the strategy
/// and a DataFrame with all calculated indicator values.
pub struct StrategySignals {
    /// Vector of buy signals where 1 indicates buy and 0 indicates no action
    pub buy_signals: Vec<i32>,

    /// Vector of sell signals where 1 indicates sell and 0 indicates no action
    pub sell_signals: Vec<i32>,

    /// DataFrame containing all price data and calculated indicators
    pub indicator_values: DataFrame,
}

/// Run the trend following strategy on the given DataFrame
///
/// This strategy combines SMA crossovers, RSI levels, Bollinger Bands, and MACD
/// to generate buy and sell signals. It requires a certain number of these indicators
/// to agree before triggering a trade.
///
/// # Signal generation
///
/// Buy signals are generated when at least `min_signals_for_buy` of the following occur:
/// - Short SMA crosses above Long SMA
/// - RSI is below the oversold threshold
/// - Price is at or below the lower Bollinger Band
/// - MACD line crosses above the Signal line
///
/// Sell signals are generated when at least `min_signals_for_sell` of the following occur:
/// - Short SMA crosses below Long SMA
/// - RSI is above the overbought threshold
/// - Price is at or above the upper Bollinger Band
/// - MACD line crosses below the Signal line
///
/// # Arguments
///
/// * `df` - DataFrame containing OHLCV data with columns "open", "high", "low", "close", "volume"
/// * `params` - Strategy parameters
///
/// # Returns
///
/// * `Result<StrategySignals, PolarsError>` - Buy/sell signals and indicator values
///
/// # Example
///
/// ```rust,no_run
/// use polars::prelude::*;
/// use ta_lib_in_rust::strategy::stock::trend_following::{run_strategy, StrategyParams};
///
/// // Create or load a DataFrame with OHLCV data
/// let df = DataFrame::default(); // Replace with actual data
///
/// // Configure strategy parameters
/// let params = StrategyParams {
///     sma_short_period: 5,
///     sma_long_period: 20,
///     rsi_period: 14,
///     min_signals_for_buy: 3,
///     ..StrategyParams::default()
/// };
///
/// // Run the strategy
/// let signals = run_strategy(&df, &params).unwrap();
/// ```
pub fn run_strategy(
    df: &DataFrame,
    params: &StrategyParams,
) -> Result<StrategySignals, PolarsError> {
    // Calculate technical indicators
    let sma_short = calculate_sma(df, "close", params.sma_short_period)?;
    let sma_long = calculate_sma(df, "close", params.sma_long_period)?;
    let rsi = calculate_rsi(df, params.rsi_period, "close")?;
    let (bb_middle, bb_upper, bb_lower) =
        calculate_bollinger_bands(df, params.bb_period, params.bb_std_dev, "close")?;
    let (macd, macd_signal) = calculate_macd(
        df,
        params.macd_fast,
        params.macd_slow,
        params.macd_signal,
        "close",
    )?;

    // Extract values for calculations
    let close = df.column("close")?.f64()?;

    // Fix temporary value dropped while borrowed errors
    let sma_short_cloned = sma_short.clone();
    let sma_short_vals = sma_short_cloned.f64()?;

    let sma_long_cloned = sma_long.clone();
    let sma_long_vals = sma_long_cloned.f64()?;

    let rsi_cloned = rsi.clone();
    let rsi_vals = rsi_cloned.f64()?;

    let bb_upper_cloned = bb_upper.clone();
    let bb_upper_vals = bb_upper_cloned.f64()?;

    let bb_lower_cloned = bb_lower.clone();
    let bb_lower_vals = bb_lower_cloned.f64()?;

    let macd_cloned = macd.clone();
    let macd_vals = macd_cloned.f64()?;

    let macd_signal_cloned = macd_signal.clone();
    let macd_signal_vals = macd_signal_cloned.f64()?;

    // Create arrays for buy/sell signals
    let mut buy_signals = Vec::with_capacity(df.height());
    let mut sell_signals = Vec::with_capacity(df.height());
    let mut is_in_position = false;

    // The maximum window size needed
    let max_window = params
        .sma_long_period
        .max(params.rsi_period)
        .max(params.bb_period)
        .max(params.macd_slow + params.macd_signal);

    // Process each data point
    for i in 0..df.height() {
        // Skip initial rows where we don't have enough data for all indicators
        if i < max_window {
            buy_signals.push(0);
            sell_signals.push(0);
            continue;
        }

        // Initialize signal counters
        let mut buy_signal_count = 0;
        let mut sell_signal_count = 0;

        // 1. SMA Crossover
        if i > 0 && sma_short_vals.get(i - 1).unwrap_or(f64::NAN) <= sma_long_vals.get(i - 1).unwrap_or(f64::NAN)
            && sma_short_vals.get(i).unwrap_or(f64::NAN) > sma_long_vals.get(i).unwrap_or(f64::NAN)
        {
            buy_signal_count += 1;
        }
        if i > 0 && sma_short_vals.get(i - 1).unwrap_or(f64::NAN) >= sma_long_vals.get(i - 1).unwrap_or(f64::NAN)
            && sma_short_vals.get(i).unwrap_or(f64::NAN) < sma_long_vals.get(i).unwrap_or(f64::NAN)
        {
            sell_signal_count += 1;
        }

        // 2. RSI Levels
        let current_rsi = rsi_vals.get(i).unwrap_or(f64::NAN);
        if !current_rsi.is_nan() {
            if current_rsi <= params.rsi_oversold {
                buy_signal_count += 1;
            }
            if current_rsi >= params.rsi_overbought {
                sell_signal_count += 1;
            }
        }

        // 3. Bollinger Bands
        let current_close = close.get(i).unwrap_or(f64::NAN);
        let current_lower_band = bb_lower_vals.get(i).unwrap_or(f64::NAN);
        let current_upper_band = bb_upper_vals.get(i).unwrap_or(f64::NAN);

        if !current_close.is_nan() && !current_lower_band.is_nan() && current_close <= current_lower_band {
            buy_signal_count += 1;
        }
        if !current_close.is_nan() && !current_upper_band.is_nan() && current_close >= current_upper_band {
            sell_signal_count += 1;
        }

        // 4. MACD Crossover
        if i > 0 && macd_vals.get(i - 1).unwrap_or(f64::NAN) <= macd_signal_vals.get(i - 1).unwrap_or(f64::NAN)
            && macd_vals.get(i).unwrap_or(f64::NAN) > macd_signal_vals.get(i).unwrap_or(f64::NAN)
        {
            buy_signal_count += 1;
        }
        if i > 0 && macd_vals.get(i - 1).unwrap_or(f64::NAN) >= macd_signal_vals.get(i - 1).unwrap_or(f64::NAN)
            && macd_vals.get(i).unwrap_or(f64::NAN) < macd_signal_vals.get(i).unwrap_or(f64::NAN)
        {
            sell_signal_count += 1;
        }

        // Generate final signals
        if !is_in_position && buy_signal_count >= params.min_signals_for_buy {
            buy_signals.push(1);
            sell_signals.push(0);
            is_in_position = true;
        } else if is_in_position && sell_signal_count >= params.min_signals_for_sell {
            buy_signals.push(0);
            sell_signals.push(1);
            is_in_position = false;
        } else {
            buy_signals.push(0);
            sell_signals.push(0);
        }
    }

    // Create a DataFrame with all indicator values
    let mut indicator_df = df.clone();
    indicator_df.with_column(sma_short)?;
    indicator_df.with_column(sma_long)?;
    indicator_df.with_column(rsi)?;
    indicator_df.with_column(bb_middle)?;
    indicator_df.with_column(bb_upper)?;
    indicator_df.with_column(bb_lower)?;
    indicator_df.with_column(macd)?;
    indicator_df.with_column(macd_signal)?;

    // Add buy/sell signals to the DataFrame
    let buy_signals_series = Series::new("buy_signals".into(), &buy_signals);
    let sell_signals_series = Series::new("sell_signals".into(), &sell_signals);
    indicator_df.with_column(buy_signals_series)?;
    indicator_df.with_column(sell_signals_series)?;

    Ok(StrategySignals {
        buy_signals,
        sell_signals,
        indicator_values: indicator_df,
    })
}

/// Calculate performance metrics for the strategy
///
/// This function simulates trading based on the generated signals and calculates
/// key performance metrics.
///
/// # Arguments
///
/// * `close_prices` - Series or Column of close prices
/// * `buy_signals` - Vector of buy signals (1 = buy, 0 = no action)
/// * `sell_signals` - Vector of sell signals (1 = sell, 0 = no action)
/// * `start_capital` - Initial capital amount
///
/// # Returns
///
/// * Tuple containing:
///   * final_portfolio_value: Final value of the portfolio
///   * total_return_pct: Total return percentage
///   * num_trades: Number of completed trades
///   * win_rate: Percentage of winning trades
///   * max_drawdown: Maximum percentage drawdown
///   * profit_factor: Ratio of gross profit to gross loss
pub fn calculate_performance(
    close_prices: &Column,
    buy_signals: &[i32],
    sell_signals: &[i32],
    start_capital: f64,
) -> (f64, f64, usize, f64, f64, f64) {
    let prices = close_prices.f64().unwrap();
    let mut capital = start_capital;
    let mut is_in_position = false;
    let mut entry_price = 0.0;
    let mut num_trades = 0;
    let mut winning_trades = 0;
    let mut losing_trades = 0;
    let mut gross_profit = 0.0;
    let mut gross_loss = 0.0;
    let mut max_capital = capital;
    let mut max_drawdown = 0.0;
    
    // Current portfolio value at each step (for tracking drawdown)
    let mut portfolio_values = Vec::with_capacity(prices.len());
    portfolio_values.push(capital);
    
    // Simulate trading
    for i in 1..prices.len() {
        let current_price = prices.get(i).unwrap_or(f64::NAN);
        
        if current_price.is_nan() {
            portfolio_values.push(capital);
            continue;
        }
        
        // Check for buy signal
        if buy_signals[i] == 1 && !is_in_position {
            entry_price = current_price;
            is_in_position = true;
        }
        // Check for sell signal
        else if sell_signals[i] == 1 && is_in_position {
            let shares = capital / entry_price;
            capital = shares * current_price;
            
            // Track trade performance
            num_trades += 1;
            let trade_return = (current_price - entry_price) / entry_price;
            
            if trade_return > 0.0 {
                winning_trades += 1;
                gross_profit += trade_return * capital;
            } else {
                losing_trades += 1;
                gross_loss += trade_return.abs() * capital;
            }
            
            is_in_position = false;
        }
        
        // Update maximum capital and drawdown
        if is_in_position {
            let current_value = capital / entry_price * current_price;
            portfolio_values.push(current_value);
            
            if current_value > max_capital {
                max_capital = current_value;
            } else {
                let drawdown = (max_capital - current_value) / max_capital;
                if drawdown > max_drawdown {
                    max_drawdown = drawdown;
                }
            }
        } else {
            portfolio_values.push(capital);
            
            if capital > max_capital {
                max_capital = capital;
            }
        }
    }
    
    // Calculate final portfolio value (including open position)
    let final_portfolio_value = if is_in_position {
        let last_price = prices.get(prices.len() - 1).unwrap_or(f64::NAN);
        if last_price.is_nan() {
            capital
        } else {
            capital / entry_price * last_price
        }
    } else {
        capital
    };
    
    // Calculate performance metrics
    let total_return_pct = (final_portfolio_value - start_capital) / start_capital * 100.0;
    let win_rate = if num_trades > 0 {
        winning_trades as f64 / num_trades as f64 * 100.0
    } else {
        0.0
    };
    let profit_factor = if gross_loss > 0.0 {
        gross_profit / gross_loss
    } else {
        if gross_profit > 0.0 { f64::INFINITY } else { 0.0 }
    };
    
    (
        final_portfolio_value,
        total_return_pct,
        num_trades,
        win_rate,
        max_drawdown * 100.0,
        profit_factor,
    )
} 