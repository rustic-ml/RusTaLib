use crate::indicators::{
    moving_averages::calculate_sma,
    oscillators::{calculate_macd, calculate_rsi},
    volatility::calculate_bollinger_bands,
};
use polars::prelude::*;

/// Strategy parameters for the standard multi-indicator strategy
///
/// This struct contains all configurable parameters that affect how
/// the strategy identifies buy and sell signals.
#[derive(Clone)]
pub struct StrategyParams {
    /// Period for short-term Simple Moving Average (SMA)
    pub sma_short_period: usize,

    /// Period for long-term Simple Moving Average (SMA)
    pub sma_long_period: usize,

    /// Period for Relative Strength Index (RSI)
    pub rsi_period: usize,

    /// RSI level considered overbought (typically 70-80)
    pub rsi_overbought: f64,

    /// RSI level considered oversold (typically 20-30)
    pub rsi_oversold: f64,

    /// Period for Bollinger Bands calculation
    pub bb_period: usize,

    /// Standard deviation multiplier for Bollinger Bands width
    pub bb_std_dev: f64,

    /// Fast period for MACD calculation
    pub macd_fast: usize,

    /// Slow period for MACD calculation
    pub macd_slow: usize,

    /// Signal period for MACD calculation
    pub macd_signal: usize,

    /// Minimum number of buy signals required to trigger a buy
    pub min_signals_for_buy: usize,

    /// Minimum number of sell signals required to trigger a sell
    pub min_signals_for_sell: usize,
}

impl Default for StrategyParams {
    /// Creates a new `StrategyParams` instance with default values
    ///
    /// # Default values
    ///
    /// - SMA short period: 10
    /// - SMA long period: 50
    /// - RSI period: 14
    /// - RSI overbought: 70.0
    /// - RSI oversold: 30.0
    /// - Bollinger Bands period: 20
    /// - Bollinger Bands std dev: 2.0
    /// - MACD fast: 12
    /// - MACD slow: 26
    /// - MACD signal: 9
    /// - Minimum signals for buy: 2
    /// - Minimum signals for sell: 2
    fn default() -> Self {
        Self {
            sma_short_period: 10,
            sma_long_period: 50,
            rsi_period: 14,
            rsi_overbought: 70.0,
            rsi_oversold: 30.0,
            bb_period: 20,
            bb_std_dev: 2.0,
            macd_fast: 12,
            macd_slow: 26,
            macd_signal: 9,
            min_signals_for_buy: 2,
            min_signals_for_sell: 2,
        }
    }
}

/// Multi-indicator strategy result with signals and indicator values
///
/// This struct contains the buy/sell signals generated by the strategy
/// and a DataFrame with all calculated indicator values.
pub struct StrategySignals {
    /// Vector of buy signals where 1 indicates buy and 0 indicates no action
    pub buy_signals: Vec<i32>,

    /// Vector of sell signals where 1 indicates sell and 0 indicates no action
    pub sell_signals: Vec<i32>,

    /// DataFrame containing all price data and calculated indicators
    pub indicator_values: DataFrame,
}

/// Run the standard multi-indicator strategy on the given DataFrame
///
/// This strategy combines SMA crossovers, RSI levels, Bollinger Bands, and MACD
/// to generate buy and sell signals. It requires a certain number of these indicators
/// to agree before triggering a trade.
///
/// # Signal generation
///
/// Buy signals are generated when at least `min_signals_for_buy` of the following occur:
/// - Short SMA crosses above Long SMA
/// - RSI is below the oversold threshold
/// - Price is at or below the lower Bollinger Band
/// - MACD line crosses above the Signal line
///
/// Sell signals are generated when at least `min_signals_for_sell` of the following occur:
/// - Short SMA crosses below Long SMA
/// - RSI is above the overbought threshold
/// - Price is at or above the upper Bollinger Band
/// - MACD line crosses below the Signal line
///
/// # Arguments
///
/// * `df` - DataFrame containing OHLCV data with columns "open", "high", "low", "close", "volume"
/// * `params` - Strategy parameters
///
/// # Returns
///
/// * `Result<StrategySignals, PolarsError>` - Buy/sell signals and indicator values
///
/// # Example
///
/// ```rust,no_run
/// use polars::prelude::*;
/// use ta_lib_in_rust::strategy::daily::multi_indicator_daily_1::{run_strategy, StrategyParams};
///
/// // Create or load a DataFrame with OHLCV data
/// let df = DataFrame::default(); // Replace with actual data
///
/// // Configure strategy parameters
/// let params = StrategyParams {
///     sma_short_period: 5,
///     sma_long_period: 20,
///     rsi_period: 14,
///     min_signals_for_buy: 3,
///     ..StrategyParams::default()
/// };
///
/// // Run the strategy
/// let signals = run_strategy(&df, &params).unwrap();
/// ```
pub fn run_strategy(
    df: &DataFrame,
    params: &StrategyParams,
) -> Result<StrategySignals, PolarsError> {
    // Calculate technical indicators
    let sma_short = calculate_sma(df, "close", params.sma_short_period)?;
    let sma_long = calculate_sma(df, "close", params.sma_long_period)?;
    let rsi = calculate_rsi(df, params.rsi_period, "close")?;
    let (bb_middle, bb_upper, bb_lower) =
        calculate_bollinger_bands(df, params.bb_period, params.bb_std_dev, "close")?;
    let (macd, macd_signal) = calculate_macd(
        df,
        params.macd_fast,
        params.macd_slow,
        params.macd_signal,
        "close",
    )?;

    // Extract values for calculations
    let close = df.column("close")?.f64()?;

    // Fix temporary value dropped while borrowed errors
    let sma_short_cloned = sma_short.clone();
    let sma_short_vals = sma_short_cloned.f64()?;

    let sma_long_cloned = sma_long.clone();
    let sma_long_vals = sma_long_cloned.f64()?;

    let rsi_cloned = rsi.clone();
    let rsi_vals = rsi_cloned.f64()?;

    let bb_upper_cloned = bb_upper.clone();
    let bb_upper_vals = bb_upper_cloned.f64()?;

    let bb_lower_cloned = bb_lower.clone();
    let bb_lower_vals = bb_lower_cloned.f64()?;

    let macd_cloned = macd.clone();
    let macd_vals = macd_cloned.f64()?;

    let macd_signal_cloned = macd_signal.clone();
    let macd_signal_vals = macd_signal_cloned.f64()?;

    // Create arrays for buy/sell signals
    let mut buy_signals = Vec::with_capacity(df.height());
    let mut sell_signals = Vec::with_capacity(df.height());
    let mut is_in_position = false;

    // The maximum window size needed
    let max_window = params
        .sma_long_period
        .max(params.macd_slow + params.macd_signal);

    // Fill the first max_window elements with 0
    for _ in 0..max_window {
        buy_signals.push(0);
        sell_signals.push(0);
    }

    // Main strategy logic
    for i in max_window..df.height() {
        // Skip if we don't have valid values
        if sma_short_vals.get(i).is_none()
            || sma_long_vals.get(i).is_none()
            || rsi_vals.get(i).is_none()
            || bb_upper_vals.get(i).is_none()
            || bb_lower_vals.get(i).is_none()
            || macd_vals.get(i).is_none()
            || macd_signal_vals.get(i).is_none()
        {
            buy_signals.push(0);
            sell_signals.push(0);
            continue;
        }

        // Extract values
        let price = close.get(i).unwrap_or(0.0);
        let sma_short_val = sma_short_vals.get(i).unwrap_or(0.0);
        let sma_long_val = sma_long_vals.get(i).unwrap_or(0.0);
        let rsi_val = rsi_vals.get(i).unwrap_or(0.0);
        let bb_upper_val = bb_upper_vals.get(i).unwrap_or(0.0);
        let bb_lower_val = bb_lower_vals.get(i).unwrap_or(0.0);
        let macd_val = macd_vals.get(i).unwrap_or(0.0);
        let macd_signal_val = macd_signal_vals.get(i).unwrap_or(0.0);

        // Previous values
        let prev_macd = if i > 0 {
            macd_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let prev_macd_signal = if i > 0 {
            macd_signal_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };

        // Check for buy signals
        let sma_cross_up = sma_short_val > sma_long_val
            && (i > 0
                && sma_short_vals.get(i - 1).unwrap_or(0.0)
                    <= sma_long_vals.get(i - 1).unwrap_or(0.0));
        let rsi_oversold = rsi_val < params.rsi_oversold;
        let price_at_bb_lower = price <= bb_lower_val;
        let macd_cross_up = macd_val > macd_signal_val && prev_macd <= prev_macd_signal;

        // Check for sell signals
        let sma_cross_down = sma_short_val < sma_long_val
            && (i > 0
                && sma_short_vals.get(i - 1).unwrap_or(0.0)
                    >= sma_long_vals.get(i - 1).unwrap_or(0.0));
        let rsi_overbought = rsi_val > params.rsi_overbought;
        let price_at_bb_upper = price >= bb_upper_val;
        let macd_cross_down = macd_val < macd_signal_val && prev_macd >= prev_macd_signal;

        // Combined signal logic
        let buy_score = (if sma_cross_up { 1 } else { 0 })
            + (if rsi_oversold { 1 } else { 0 })
            + (if price_at_bb_lower { 1 } else { 0 })
            + (if macd_cross_up { 1 } else { 0 });

        let sell_score = (if sma_cross_down { 1 } else { 0 })
            + (if rsi_overbought { 1 } else { 0 })
            + (if price_at_bb_upper { 1 } else { 0 })
            + (if macd_cross_down { 1 } else { 0 });

        // Final decision using configurable thresholds
        let buy_signal = if !is_in_position && buy_score >= params.min_signals_for_buy {
            1
        } else {
            0
        };
        let sell_signal = if is_in_position && sell_score >= params.min_signals_for_sell {
            1
        } else {
            0
        };

        buy_signals.push(buy_signal);
        sell_signals.push(sell_signal);

        // Update position status
        if buy_signal == 1 {
            is_in_position = true;
        } else if sell_signal == 1 {
            is_in_position = false;
        }
    }

    // Create a new DataFrame with all indicators
    let mut indicator_df = df.clone();

    // Add indicators to the DataFrame
    let _ = indicator_df.with_column(sma_short.with_name("sma_short".into()));
    let _ = indicator_df.with_column(sma_long.with_name("sma_long".into()));
    let _ = indicator_df.with_column(rsi.with_name("rsi".into()));
    let _ = indicator_df.with_column(bb_middle.with_name("bb_middle".into()));
    let _ = indicator_df.with_column(bb_upper.with_name("bb_upper".into()));
    let _ = indicator_df.with_column(bb_lower.with_name("bb_lower".into()));
    let _ = indicator_df.with_column(macd.with_name("macd".into()));
    let _ = indicator_df.with_column(macd_signal.with_name("macd_signal".into()));

    // Add buy and sell signals
    let buy_series = Series::new("buy_signal".into(), &buy_signals);
    let sell_series = Series::new("sell_signal".into(), &sell_signals);
    let _ = indicator_df.with_column(buy_series);
    let _ = indicator_df.with_column(sell_series);

    Ok(StrategySignals {
        buy_signals,
        sell_signals,
        indicator_values: indicator_df,
    })
}

/// Calculate performance metrics based on buy/sell signals
///
/// This function takes the buy and sell signals generated by the strategy
/// and calculates various performance metrics to evaluate the strategy's effectiveness.
///
/// # Performance metrics calculated
///
/// - Final Value: The ending portfolio value
/// - Total Return: The percentage return compared to initial capital
/// - Number of Trades: Total number of completed trades (buy followed by sell)
/// - Win Rate: Percentage of profitable trades
/// - Maximum Drawdown: The largest percentage drop from peak to trough
/// - Profit Factor: Ratio of gross profits to gross losses
///
/// # Arguments
///
/// * `close_prices` - Column of close prices
/// * `buy_signals` - Vector of buy signals (0 or 1)
/// * `sell_signals` - Vector of sell signals (0 or 1)
/// * `start_capital` - Starting capital amount
///
/// # Returns
///
/// A tuple containing (final_value, total_return, num_trades, win_rate, max_drawdown, profit_factor)
///
/// # Example
///
/// ```rust,no_run
/// use polars::prelude::*;
/// use ta_lib_in_rust::strategy::daily::multi_indicator_daily_1::{run_strategy, calculate_performance, StrategyParams};
///
/// // Create or load a DataFrame with OHLCV data
/// let df = DataFrame::default(); // Replace with actual data
/// let params = StrategyParams::default();
///
/// // Run the strategy
/// let signals = run_strategy(&df, &params).unwrap();
///
/// // Calculate performance
/// let close_prices = df.column("close").unwrap();
/// let (final_value, return_pct, num_trades, win_rate, max_drawdown, profit_factor) =
///     calculate_performance(close_prices, &signals.buy_signals, &signals.sell_signals, 10000.0);
///
/// println!("Strategy return: {:.2}%", return_pct);
/// println!("Win rate: {:.2}%", win_rate);
/// ```
pub fn calculate_performance(
    close_prices: &Column,
    buy_signals: &[i32],
    sell_signals: &[i32],
    start_capital: f64,
) -> (f64, f64, usize, f64, f64, f64) {
    let close = close_prices.f64().unwrap();
    let mut capital = start_capital;
    let mut shares = 0.0;
    let mut trades = 0;
    let mut wins = 0;
    let mut losses = 0;
    let mut buy_price = 0.0;
    let mut total_profit = 0.0;
    let mut total_loss = 0.0;
    let mut equity_curve = Vec::with_capacity(close.len());
    let mut max_equity = start_capital;
    let mut max_drawdown = 0.0;

    // Determine starting point with valid signals
    let start_idx = buy_signals
        .iter()
        .position(|&x| x == 1)
        .unwrap_or(0)
        .saturating_sub(1);

    // Initialize equity curve
    for _ in 0..close.len() {
        equity_curve.push(start_capital);
    }

    // Process signals
    for i in start_idx..close.len() {
        let price = close.get(i).unwrap_or(0.0);
        let buy_signal = buy_signals[i];
        let sell_signal = sell_signals[i];

        if buy_signal == 1 {
            shares = capital / price;
            capital = 0.0;
            buy_price = price;
            trades += 1;
        } else if sell_signal == 1 {
            capital = shares * price;
            let trade_profit = capital - (shares * buy_price);

            if trade_profit > 0.0 {
                wins += 1;
                total_profit += trade_profit;
            } else {
                losses += 1;
                total_loss += trade_profit.abs();
            }

            shares = 0.0;
        }

        // Update equity curve
        let current_equity = capital + (shares * price);
        equity_curve[i] = current_equity;

        // Update max equity and drawdown
        if current_equity > max_equity {
            max_equity = current_equity;
        } else {
            let drawdown = (max_equity - current_equity) / max_equity;
            if drawdown > max_drawdown {
                max_drawdown = drawdown;
            }
        }
    }

    // Final calculations
    let final_price = close.get(close.len() - 1).unwrap_or(0.0);
    let final_value = capital + (shares * final_price);
    let total_return = (final_value / start_capital - 1.0) * 100.0;
    let win_rate = if trades > 0 {
        (wins as f64 / trades as f64) * 100.0
    } else {
        0.0
    };
    let profit_factor = if total_loss > 0.0 {
        total_profit / total_loss
    } else {
        0.0
    };

    (
        final_value,
        total_return,
        trades,
        win_rate,
        max_drawdown,
        profit_factor,
    )
}
