use crate::indicators::{
    moving_averages::{calculate_ema, calculate_wma},
    oscillators::{calculate_macd, calculate_rsi},
    volatility::{calculate_atr, calculate_bollinger_bands},
};
use polars::prelude::*;

/// Strategy parameters for a volatility-focused minute-based strategy
///
/// This strategy adapts to market volatility by using ATR and Bollinger Bands
/// to set dynamic entry/exit rules.
#[derive(Clone)]
pub struct StrategyParams {
    /// Period for fast Exponential Moving Average (EMA)
    pub ema_fast_period: usize,

    /// Period for slow Exponential Moving Average (EMA)
    pub ema_slow_period: usize,

    /// Period for Weighted Moving Average (WMA)
    pub wma_period: usize,

    /// Period for Relative Strength Index (RSI)
    pub rsi_period: usize,

    /// RSI level considered overbought
    pub rsi_overbought: f64,

    /// RSI level considered oversold
    pub rsi_oversold: f64,

    /// Fast period for MACD calculation
    pub macd_fast: usize,

    /// Slow period for MACD calculation
    pub macd_slow: usize,

    /// Signal period for MACD calculation
    pub macd_signal: usize,

    /// Period for Average True Range (ATR)
    pub atr_period: usize,

    /// ATR multiplier for position sizing
    pub atr_position_size_factor: f64,

    /// Period for Bollinger Bands calculation
    pub bb_period: usize,

    /// Standard deviation multiplier for Bollinger Bands width
    pub bb_std_dev: f64,

    /// Whether to use ATR-based position sizing
    pub use_atr_position_sizing: bool,

    /// Whether to use trading hours filtering
    pub use_trading_hours_filter: bool,

    /// Trading session start hour
    pub trading_session_start_hour: usize,

    /// Trading session end hour
    pub trading_session_end_hour: usize,
}

impl Default for StrategyParams {
    /// Creates a new `StrategyParams` instance with default values
    ///
    /// # Default values
    ///
    /// - EMA fast period: 8 (8 minutes)
    /// - EMA slow period: 21 (21 minutes)
    /// - WMA period: 14 (14 minutes)
    /// - RSI period: 6 (faster for intraday trading)
    /// - RSI overbought: 70.0
    /// - RSI oversold: 30.0
    /// - MACD fast: 6
    /// - MACD slow: 13
    /// - MACD signal: 4
    /// - ATR period: 14
    /// - ATR position size factor: 2.0
    /// - Bollinger period: 20
    /// - Bollinger std dev: 2.0
    /// - Use ATR position sizing: true
    /// - Use trading hours filter: true
    /// - Trading session start hour: 9 (9:00 AM)
    /// - Trading session end hour: 16 (4:00 PM)
    fn default() -> Self {
        Self {
            ema_fast_period: 8,
            ema_slow_period: 21,
            wma_period: 14,
            rsi_period: 6,
            rsi_overbought: 70.0,
            rsi_oversold: 30.0,
            macd_fast: 6,
            macd_slow: 13,
            macd_signal: 4,
            atr_period: 14,
            atr_position_size_factor: 2.0,
            bb_period: 20,
            bb_std_dev: 2.0,
            use_atr_position_sizing: true,
            use_trading_hours_filter: true,
            trading_session_start_hour: 9,
            trading_session_end_hour: 16,
        }
    }
}

/// Multi-indicator minute strategy result with signals and indicator values
///
/// This struct contains the buy/sell signals generated by the strategy,
/// position sizes, and a DataFrame with all calculated indicators.
pub struct StrategySignals {
    /// Vector of buy signals where 1 indicates buy and 0 indicates no action
    pub buy_signals: Vec<i32>,

    /// Vector of sell signals where 1 indicates sell and 0 indicates no action
    pub sell_signals: Vec<i32>,

    /// Vector of position sizes as percentage of capital (0.0 to 1.0)
    pub position_sizes: Vec<f64>,

    /// DataFrame containing all price data and calculated indicators
    pub indicator_values: DataFrame,
}

/// Run the volatility-focused minute-based strategy on the given DataFrame
///
/// This strategy uses EMA crossovers, RSI, MACD, and Bollinger Bands
/// to generate signals, with special focus on using ATR for position sizing
/// and volatility-based entries/exits.
///
/// # Signal generation
///
/// Buy signals are generated when:
/// - Fast EMA crosses above Slow EMA
/// - RSI is below the oversold threshold
/// - MACD line crosses above the Signal line
/// - Price breaks above the upper Bollinger Band
///
/// Sell signals are generated when:
/// - Fast EMA crosses below Slow EMA
/// - RSI is above the overbought threshold
/// - MACD line crosses below the Signal line
/// - Price breaks below the lower Bollinger Band
///
/// # Position sizing
///
/// If ATR-based position sizing is enabled, the position size is determined
/// by the inverse of ATR - higher volatility leads to smaller position sizes.
///
/// # Arguments
///
/// * `df` - DataFrame containing OHLCV data
/// * `params` - Strategy parameters
///
/// # Returns
///
/// * `Result<StrategySignals, PolarsError>` - Buy/sell signals, position sizes, and indicator values
pub fn run_strategy(
    df: &DataFrame,
    params: &StrategyParams,
) -> Result<StrategySignals, PolarsError> {
    // Calculate technical indicators
    let ema_fast = calculate_ema(df, "close", params.ema_fast_period)?;
    let ema_slow = calculate_ema(df, "close", params.ema_slow_period)?;
    let wma = calculate_wma(df, "close", params.wma_period)?;
    let rsi = calculate_rsi(df, params.rsi_period, "close")?;
    let (macd, macd_signal) = calculate_macd(
        df,
        params.macd_fast,
        params.macd_slow,
        params.macd_signal,
        "close",
    )?;
    let atr = calculate_atr(df, params.atr_period)?;
    let (_bb_middle, bb_upper, bb_lower) =
        calculate_bollinger_bands(df, params.bb_period, params.bb_std_dev, "close")?;

    // Extract values for calculations
    let close = df.column("close")?.f64()?;
    let high = df.column("high")?.f64()?;
    let low = df.column("low")?.f64()?;

    // Fix temporary value dropped while borrowed errors
    let ema_fast_cloned = ema_fast.clone();
    let ema_fast_vals = ema_fast_cloned.f64()?;

    let ema_slow_cloned = ema_slow.clone();
    let ema_slow_vals = ema_slow_cloned.f64()?;

    let wma_cloned = wma.clone();
    let wma_vals = wma_cloned.f64()?;

    let rsi_cloned = rsi.clone();
    let rsi_vals = rsi_cloned.f64()?;

    let macd_cloned = macd.clone();
    let macd_vals = macd_cloned.f64()?;

    let macd_signal_cloned = macd_signal.clone();
    let macd_signal_vals = macd_signal_cloned.f64()?;

    let atr_cloned = atr.clone();
    let atr_vals = atr_cloned.f64()?;

    let bb_upper_cloned = bb_upper.clone();
    let bb_upper_vals = bb_upper_cloned.f64()?;

    let bb_lower_cloned = bb_lower.clone();
    let bb_lower_vals = bb_lower_cloned.f64()?;

    // Create arrays for buy/sell signals and position sizes
    let mut buy_signals = Vec::with_capacity(df.height());
    let mut sell_signals = Vec::with_capacity(df.height());
    let mut position_sizes = Vec::with_capacity(df.height());
    let mut is_in_position = false;

    // The maximum window size needed for calculations
    let max_window = params
        .ema_slow_period
        .max(params.atr_period)
        .max(params.bb_period)
        .max(params.macd_slow + params.macd_signal);

    // Fill the first max_window elements with 0
    for _ in 0..max_window {
        buy_signals.push(0);
        sell_signals.push(0);
        position_sizes.push(0.0);
    }

    // Extract time column for trading hours filtering if available
    let has_time_column = df.schema().contains("time");
    let time_series = if has_time_column {
        Some(df.column("time")?)
    } else {
        None
    };

    // Main strategy logic
    for i in max_window..df.height() {
        // Skip if we don't have valid values
        if ema_fast_vals.get(i).is_none()
            || ema_slow_vals.get(i).is_none()
            || wma_vals.get(i).is_none()
            || rsi_vals.get(i).is_none()
            || macd_vals.get(i).is_none()
            || macd_signal_vals.get(i).is_none()
            || atr_vals.get(i).is_none()
            || bb_upper_vals.get(i).is_none()
            || bb_lower_vals.get(i).is_none()
        {
            buy_signals.push(0);
            sell_signals.push(0);
            position_sizes.push(0.0);
            continue;
        }

        // Check trading hours if filtering is enabled
        let is_trading_hours = if params.use_trading_hours_filter && time_series.is_some() {
            let time_str = match time_series.as_ref().unwrap().dtype() {
                DataType::String => time_series
                    .as_ref()
                    .unwrap()
                    .str()?
                    .get(i)
                    .unwrap_or("")
                    .to_string(),
                DataType::Datetime(_, _) => {
                    // Handle datetime
                    let dt = time_series.as_ref().unwrap().datetime()?.get(i);
                    if let Some(datetime) = dt {
                        let hour = datetime / 3600000000000 % 24;
                        hour.to_string()
                    } else {
                        "".to_string()
                    }
                }
                _ => "".to_string(),
            };

            // Extract the hour from the time string
            let hour: usize = time_str
                .split(' ')
                .next_back()
                .unwrap_or("")
                .split(':')
                .next()
                .unwrap_or("0")
                .parse()
                .unwrap_or(0);

            hour >= params.trading_session_start_hour && hour < params.trading_session_end_hour
        } else {
            true // If no filtering or no time column, consider all times valid
        };

        if !is_trading_hours {
            buy_signals.push(0);
            sell_signals.push(0);
            position_sizes.push(0.0);
            continue;
        }

        // Extract values
        let price = close.get(i).unwrap_or(0.0);
        let ema_fast_val = ema_fast_vals.get(i).unwrap_or(0.0);
        let ema_slow_val = ema_slow_vals.get(i).unwrap_or(0.0);
        let _wma_val = wma_vals.get(i).unwrap_or(0.0);
        let rsi_val = rsi_vals.get(i).unwrap_or(0.0);
        let macd_val = macd_vals.get(i).unwrap_or(0.0);
        let macd_signal_val = macd_signal_vals.get(i).unwrap_or(0.0);
        let atr_val = atr_vals.get(i).unwrap_or(0.0);
        let bb_upper_val = bb_upper_vals.get(i).unwrap_or(0.0);
        let bb_lower_val = bb_lower_vals.get(i).unwrap_or(0.0);

        // Previous values
        let _prev_high = if i > 0 {
            high.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let _prev_low = if i > 0 {
            low.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let prev_ema_fast = if i > 0 {
            ema_fast_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let prev_ema_slow = if i > 0 {
            ema_slow_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let prev_macd = if i > 0 {
            macd_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let prev_macd_signal = if i > 0 {
            macd_signal_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };

        // Calculate position size based on ATR
        let position_size = if params.use_atr_position_sizing && atr_val > 0.0 {
            // Smaller position for higher volatility
            let base_position = 1.0 / (params.atr_position_size_factor * atr_val / price);
            // Clamp between 0.1 and 1.0
            base_position.clamp(0.1, 1.0)
        } else {
            1.0 // Full position if not using ATR sizing
        };

        // Check for buy signals
        let ema_cross_up = ema_fast_val > ema_slow_val && prev_ema_fast <= prev_ema_slow;
        let rsi_oversold = rsi_val < params.rsi_oversold;
        let macd_cross_up = macd_val > macd_signal_val && prev_macd <= prev_macd_signal;
        let bb_breakout_up = high.get(i).unwrap_or(0.0) > bb_upper_val;

        // Check for sell signals
        let ema_cross_down = ema_fast_val < ema_slow_val && prev_ema_fast >= prev_ema_slow;
        let rsi_overbought = rsi_val > params.rsi_overbought;
        let macd_cross_down = macd_val < macd_signal_val && prev_macd >= prev_macd_signal;
        let bb_breakout_down = low.get(i).unwrap_or(0.0) < bb_lower_val;

        // Determine signals
        let buy_signal = if !is_in_position
            && (ema_cross_up || rsi_oversold || macd_cross_up || bb_breakout_up)
        {
            1
        } else {
            0
        };
        let sell_signal = if is_in_position
            && (ema_cross_down || rsi_overbought || macd_cross_down || bb_breakout_down)
        {
            1
        } else {
            0
        };

        buy_signals.push(buy_signal);
        sell_signals.push(sell_signal);
        position_sizes.push(position_size);

        // Update position status
        if buy_signal == 1 {
            is_in_position = true;
        } else if sell_signal == 1 {
            is_in_position = false;
        }
    }

    // Create a new DataFrame with all indicators
    let mut indicator_df = df.clone();

    // Add indicators to the DataFrame
    let _ = indicator_df.with_column(ema_fast.with_name("ema_fast".into()));
    let _ = indicator_df.with_column(ema_slow.with_name("ema_slow".into()));
    let _ = indicator_df.with_column(wma.with_name("wma".into()));
    let _ = indicator_df.with_column(rsi.with_name("rsi".into()));
    let _ = indicator_df.with_column(macd.with_name("macd".into()));
    let _ = indicator_df.with_column(macd_signal.with_name("macd_signal".into()));
    let _ = indicator_df.with_column(atr.with_name("atr".into()));
    let _ = indicator_df.with_column(bb_upper.with_name("bb_upper".into()));
    let _ = indicator_df.with_column(bb_lower.with_name("bb_lower".into()));

    // Add signals and position sizes
    let buy_series = Series::new("buy_signal".into(), &buy_signals);
    let sell_series = Series::new("sell_signal".into(), &sell_signals);
    let position_series = Series::new("position_size".into(), &position_sizes);

    let _ = indicator_df.with_column(buy_series);
    let _ = indicator_df.with_column(sell_series);
    let _ = indicator_df.with_column(position_series);

    Ok(StrategySignals {
        buy_signals,
        sell_signals,
        position_sizes,
        indicator_values: indicator_df,
    })
}

/// Calculate performance metrics for the volatility-focused strategy
///
/// This function takes the buy and sell signals and position sizes generated
/// by the strategy and calculates various performance metrics. It includes
/// support for variable position sizing based on volatility.
///
/// # Performance metrics calculated
///
/// - Final Value: The ending portfolio value
/// - Total Return: The percentage return compared to initial capital
/// - Number of Trades: Total number of completed trades
/// - Win Rate: Percentage of profitable trades
/// - Maximum Drawdown: The largest percentage drop from peak to trough
/// - Profit Factor: Ratio of gross profits to gross losses
/// - Sharpe Ratio: Risk-adjusted return metric (simplified)
///
/// # Arguments
///
/// * `close_prices` - Column of close prices
/// * `buy_signals` - Vector of buy signals (0 or 1)
/// * `sell_signals` - Vector of sell signals (0 or 1)
/// * `position_sizes` - Vector of position sizes (0.0 to 1.0)
/// * `start_capital` - Starting capital amount
/// * `close_positions_at_day_end` - Whether to close positions at the end of each trading day
/// * `risk_free_rate` - Annual risk-free rate for Sharpe calculation (default 0.02 or 2%)
///
/// # Returns
///
/// A tuple containing (final_value, total_return, num_trades, win_rate, max_drawdown, profit_factor, sharpe_ratio)
pub fn calculate_performance(
    close_prices: &Column,
    buy_signals: &[i32],
    sell_signals: &[i32],
    position_sizes: &[f64],
    start_capital: f64,
    close_positions_at_day_end: bool,
    risk_free_rate: Option<f64>,
) -> (f64, f64, usize, f64, f64, f64, f64) {
    let close = close_prices.f64().unwrap();
    let mut capital = start_capital;
    let mut shares = 0.0;
    let mut trades = 0;
    let mut wins = 0;
    let mut _losses = 0;
    let mut buy_price = 0.0;
    let mut total_profit = 0.0;
    let mut total_loss = 0.0;
    let mut equity_curve = Vec::with_capacity(close.len());
    let mut daily_returns = Vec::new();
    let mut max_equity = start_capital;
    let mut max_drawdown = 0.0;

    // Track the current day for end-of-day closing
    let mut current_day = 0;

    // Set risk free rate (default to 2% annual)
    let risk_free = risk_free_rate.unwrap_or(0.02);

    // Determine starting point with valid signals
    let start_idx = buy_signals
        .iter()
        .position(|&x| x == 1)
        .unwrap_or(0)
        .saturating_sub(1);

    // Initialize equity curve
    for _ in 0..close.len() {
        equity_curve.push(start_capital);
    }

    // For daily returns calculation
    let mut prev_equity = start_capital;

    // Process signals
    for i in start_idx..close.len() {
        let price = close.get(i).unwrap_or(0.0);
        let buy_signal = buy_signals[i];
        let sell_signal = sell_signals[i];

        // Get position size (between 0.0 and 1.0)
        let position_size = position_sizes.get(i).copied().unwrap_or(1.0);

        // Check for day change if close_positions_at_day_end is enabled
        // This is simplified - in practice you'd use the time/date column
        let day = i / 390; // Assuming 390 minutes in a trading day (6.5 hours)

        if close_positions_at_day_end && day != current_day && shares > 0.0 {
            // End of day - close any open position
            let position_value = shares * price;
            let trade_profit = position_value - (shares * buy_price);

            capital += position_value;

            if trade_profit > 0.0 {
                wins += 1;
                total_profit += trade_profit;
            } else {
                _losses += 1;
                total_loss += trade_profit.abs();
            }

            shares = 0.0;
            trades += 1;
            current_day = day;
        } else {
            current_day = day;
        }

        // Process buy signals with position sizing
        if buy_signal == 1 && shares == 0.0 {
            let investment_amount = capital * position_size;
            shares = investment_amount / price;
            capital -= investment_amount;
            buy_price = price;
            trades += 1;
        }
        // Process sell signals
        else if sell_signal == 1 && shares > 0.0 {
            let position_value = shares * price;
            let trade_profit = position_value - (shares * buy_price);

            capital += position_value;

            if trade_profit > 0.0 {
                wins += 1;
                total_profit += trade_profit;
            } else {
                _losses += 1;
                total_loss += trade_profit.abs();
            }

            shares = 0.0;
        }

        // Update equity curve
        let current_equity = capital + (shares * price);
        equity_curve[i] = current_equity;

        // Calculate daily returns at day boundaries
        if day != current_day {
            let daily_return = (current_equity / prev_equity) - 1.0;
            daily_returns.push(daily_return);
            prev_equity = current_equity;
        }

        // Update max equity and drawdown
        if current_equity > max_equity {
            max_equity = current_equity;
        } else {
            let drawdown = (max_equity - current_equity) / max_equity;
            if drawdown > max_drawdown {
                max_drawdown = drawdown;
            }
        }
    }

    // Close any open position at the end of the backtest
    if shares > 0.0 {
        let final_price = close.get(close.len() - 1).unwrap_or(0.0);
        capital += shares * final_price;
    }

    // Calculate Sharpe ratio
    let final_value = capital;
    let mean_daily_return = if !daily_returns.is_empty() {
        daily_returns.iter().sum::<f64>() / daily_returns.len() as f64
    } else {
        0.0
    };

    let daily_return_std_dev = if daily_returns.len() > 1 {
        let mean = mean_daily_return;
        let variance = daily_returns
            .iter()
            .map(|&r| (r - mean).powi(2))
            .sum::<f64>()
            / (daily_returns.len() - 1) as f64;
        variance.sqrt()
    } else {
        0.0
    };

    // Annualized Sharpe ratio (assuming 252 trading days per year)
    let sharpe_ratio = if daily_return_std_dev > 0.0 {
        let annualized_return = mean_daily_return * 252.0;
        let annualized_std_dev = daily_return_std_dev * (252.0_f64).sqrt();
        (annualized_return - risk_free) / annualized_std_dev
    } else {
        0.0
    };

    // Final calculations
    let total_return = (final_value / start_capital - 1.0) * 100.0;
    let win_rate = if trades > 0 {
        (wins as f64 / trades as f64) * 100.0
    } else {
        0.0
    };
    let profit_factor = if total_loss > 0.0 {
        total_profit / total_loss
    } else {
        0.0
    };

    (
        final_value,
        total_return,
        trades,
        win_rate,
        max_drawdown,
        profit_factor,
        sharpe_ratio,
    )
}
