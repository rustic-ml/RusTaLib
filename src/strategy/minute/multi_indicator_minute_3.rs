use crate::indicators::{
    momentum::calculate_roc,
    moving_averages::{calculate_ema, calculate_vwap},
    oscillators::{calculate_macd, calculate_rsi},
    volatility::{calculate_atr, calculate_bollinger_bands},
};
use polars::prelude::*;

/// Strategy parameters for a momentum-focused minute-based strategy
///
/// This strategy is designed for intraday momentum trading with time-based filters
/// to capture momentum moves during specific time periods.
#[derive(Clone)]
pub struct StrategyParams {
    /// Period for Exponential Moving Average (EMA)
    pub ema_period: usize,

    /// Period for VWAP calculation
    pub vwap_lookback: usize,

    /// Period for Relative Strength Index (RSI)
    pub rsi_period: usize,

    /// RSI threshold for momentum confirmation
    pub rsi_threshold: f64,

    /// Period for Rate of Change (ROC) momentum indicator
    pub roc_period: usize,

    /// ROC threshold for momentum confirmation (in percent)
    pub roc_threshold: f64,

    /// Fast period for MACD calculation
    pub macd_fast: usize,

    /// Slow period for MACD calculation
    pub macd_slow: usize,

    /// Signal period for MACD calculation
    pub macd_signal: usize,

    /// Period for Average True Range (ATR)
    pub atr_period: usize,

    /// ATR multiplier for stop loss placement
    pub atr_stop_multiplier: f64,

    /// ATR multiplier for take profit placement
    pub atr_profit_multiplier: f64,

    /// Period for Bollinger Bands calculation
    pub bb_period: usize,

    /// Standard deviation multiplier for Bollinger Bands
    pub bb_std_dev: f64,

    /// Whether to apply morning trading hour filter (9:30-11:00 AM)
    pub filter_morning_session: bool,

    /// Whether to apply lunch trading hour filter (11:30-13:30)
    pub filter_lunch_session: bool,

    /// Whether to apply afternoon trading hour filter (14:00-16:00)
    pub filter_afternoon_session: bool,

    /// Whether to use volume confirmation for signals
    pub use_volume_confirmation: bool,

    /// Volume threshold as a percentage of average volume
    pub volume_threshold: f64,
}

impl Default for StrategyParams {
    /// Creates a new `StrategyParams` instance with default values
    ///
    /// # Default values for momentum trading
    ///
    /// - EMA period: 9 (9 minutes)
    /// - VWAP lookback: 390 (full trading day)
    /// - RSI period: 5 (sensitive to short-term momentum)
    /// - RSI threshold: 55.0 (for bullish momentum, below 45 for bearish)
    /// - ROC period: 5 (5-minute momentum)
    /// - ROC threshold: 0.2 (0.2% minimum momentum)
    /// - MACD fast: 6
    /// - MACD slow: 13
    /// - MACD signal: 4
    /// - ATR period: 10
    /// - ATR stop multiplier: 2.0
    /// - ATR profit multiplier: 3.0
    /// - BB period: 20
    /// - BB std dev: 2.0
    /// - Filter morning session: true
    /// - Filter lunch session: false
    /// - Filter afternoon session: true
    /// - Use volume confirmation: true
    /// - Volume threshold: 1.5 (150% of average volume)
    fn default() -> Self {
        Self {
            ema_period: 9,
            vwap_lookback: 390,
            rsi_period: 5,
            rsi_threshold: 55.0,
            roc_period: 5,
            roc_threshold: 0.2,
            macd_fast: 6,
            macd_slow: 13,
            macd_signal: 4,
            atr_period: 10,
            atr_stop_multiplier: 2.0,
            atr_profit_multiplier: 3.0,
            bb_period: 20,
            bb_std_dev: 2.0,
            filter_morning_session: true,
            filter_lunch_session: false,
            filter_afternoon_session: true,
            use_volume_confirmation: true,
            volume_threshold: 1.5,
        }
    }
}

/// Momentum strategy signals with risk management levels
///
/// This struct contains the buy/sell signals generated by the strategy,
/// along with stop loss and take profit levels for each trade.
pub struct StrategySignals {
    /// Vector of buy signals where 1 indicates buy and 0 indicates no action
    pub buy_signals: Vec<i32>,

    /// Vector of sell signals where 1 indicates sell and 0 indicates no action
    pub sell_signals: Vec<i32>,

    /// Vector of stop loss prices for each entry
    pub stop_levels: Vec<f64>,

    /// Vector of take profit prices for each entry
    pub target_levels: Vec<f64>,

    /// DataFrame containing all price data and calculated indicators
    pub indicator_values: DataFrame,
}

/// Run the momentum-focused minute-based strategy on the given DataFrame
///
/// This strategy is designed to capture intraday momentum with a focus on specific
/// time periods that tend to have stronger directional moves. It uses a combination
/// of momentum indicators (RSI, ROC, MACD) along with price-volume relationships
/// and technical support/resistance levels.
///
/// # Signal generation
///
/// Buy signals are generated when:
/// - Price is above the EMA and VWAP (bullish trend)
/// - RSI is above the threshold (indicating momentum)
/// - ROC is above the threshold (confirming momentum)
/// - MACD line crosses above Signal line (entry timing)
/// - Volume is above threshold (if volume confirmation is enabled)
/// - Current time is within the allowed trading sessions
///
/// Sell signals are generated when:
/// - Stop loss or take profit levels are hit
/// - Price crosses below EMA
/// - RSI drops below inverse threshold
/// - MACD line crosses below Signal line
///
/// # Risk management
///
/// - Stop loss levels are set using ATR * stop_multiplier below entry
/// - Take profit levels are set using ATR * profit_multiplier above entry
///
/// # Arguments
///
/// * `df` - DataFrame containing OHLCV data with a time column
/// * `params` - Strategy parameters
///
/// # Returns
///
/// * `Result<StrategySignals, PolarsError>` - Buy/sell signals, stop/target levels, and indicator values
pub fn run_strategy(
    df: &DataFrame,
    params: &StrategyParams,
) -> Result<StrategySignals, PolarsError> {
    // Calculate technical indicators
    let ema = calculate_ema(df, "close", params.ema_period)?;
    let vwap = calculate_vwap(df, params.vwap_lookback)?;
    let rsi = calculate_rsi(df, params.rsi_period, "close")?;
    let roc = calculate_roc(df, params.roc_period, "close")?;
    let (macd, macd_signal) = calculate_macd(
        df,
        params.macd_fast,
        params.macd_slow,
        params.macd_signal,
        "close",
    )?;
    let atr = calculate_atr(df, params.atr_period)?;
    let (_bb_middle, bb_upper, bb_lower) =
        calculate_bollinger_bands(df, params.bb_period, params.bb_std_dev, "close")?;

    // Extract values for calculations
    let close = df.column("close")?.f64()?;
    let _high = df.column("high")?.f64()?;
    let _low = df.column("low")?.f64()?;
    let volume = df.column("volume")?.f64()?;

    // Fix temporary value dropped while borrowed errors
    let ema_cloned = ema.clone();
    let ema_vals = ema_cloned.f64()?;

    let vwap_cloned = vwap.clone();
    let vwap_vals = vwap_cloned.f64()?;

    let rsi_cloned = rsi.clone();
    let rsi_vals = rsi_cloned.f64()?;

    let roc_cloned = roc.clone();
    let roc_vals = roc_cloned.f64()?;

    let macd_cloned = macd.clone();
    let macd_vals = macd_cloned.f64()?;

    let macd_signal_cloned = macd_signal.clone();
    let macd_signal_vals = macd_signal_cloned.f64()?;

    let atr_cloned = atr.clone();
    let atr_vals = atr_cloned.f64()?;

    let bb_upper_cloned = bb_upper.clone();
    let _bb_upper_vals = bb_upper_cloned.f64()?;

    let bb_lower_cloned = bb_lower.clone();
    let _bb_lower_vals = bb_lower_cloned.f64()?;

    // Create arrays for signals and levels
    let mut buy_signals = Vec::with_capacity(df.height());
    let mut sell_signals = Vec::with_capacity(df.height());
    let mut stop_levels = Vec::with_capacity(df.height());
    let mut target_levels = Vec::with_capacity(df.height());
    let mut is_in_position = false;
    let mut current_stop = 0.0;
    let mut current_target = 0.0;

    // Calculate average volume for comparison
    let avg_volume: f64 = volume
        .iter()
        .filter_map(|v| v)
        .take(100) // Use first 100 values or fewer
        .sum::<f64>()
        / 100.0;

    // The maximum window size needed for calculations
    let max_window = params
        .ema_period
        .max(params.rsi_period)
        .max(params.roc_period)
        .max(params.macd_slow + params.macd_signal)
        .max(params.bb_period)
        .max(params.atr_period);

    // Fill the first max_window elements with 0 and placeholder values
    for _ in 0..max_window {
        buy_signals.push(0);
        sell_signals.push(0);
        stop_levels.push(0.0);
        target_levels.push(0.0);
    }

    // Extract time column for trading session filtering
    let has_time_column = df.schema().contains("time");
    let time_series = if has_time_column {
        Some(df.column("time")?)
    } else {
        None
    };

    // Main strategy logic
    for i in max_window..df.height() {
        // Skip if we don't have valid values
        if ema_vals.get(i).is_none()
            || vwap_vals.get(i).is_none()
            || rsi_vals.get(i).is_none()
            || roc_vals.get(i).is_none()
            || macd_vals.get(i).is_none()
            || macd_signal_vals.get(i).is_none()
            || atr_vals.get(i).is_none()
        {
            buy_signals.push(0);
            sell_signals.push(0);
            stop_levels.push(0.0);
            target_levels.push(0.0);
            continue;
        }

        // Extract current values
        let price = close.get(i).unwrap_or(0.0);
        let ema_val = ema_vals.get(i).unwrap_or(0.0);
        let vwap_val = vwap_vals.get(i).unwrap_or(0.0);
        let rsi_val = rsi_vals.get(i).unwrap_or(0.0);
        let roc_val = roc_vals.get(i).unwrap_or(0.0);
        let macd_val = macd_vals.get(i).unwrap_or(0.0);
        let macd_signal_val = macd_signal_vals.get(i).unwrap_or(0.0);
        let atr_val = atr_vals.get(i).unwrap_or(0.0);
        let vol_val = volume.get(i).unwrap_or(0.0);

        // Previous values
        let prev_macd = if i > 0 {
            macd_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };
        let prev_macd_signal = if i > 0 {
            macd_signal_vals.get(i - 1).unwrap_or(0.0)
        } else {
            0.0
        };

        // Check if we're within allowed trading time periods
        let is_allowed_time = if let Some(time_col) = time_series.as_ref() {
            // Extract time as string
            let time_str = match time_col.dtype() {
                DataType::String => time_col.str()?.get(i).unwrap_or("").to_string(),
                DataType::Datetime(_, _) => {
                    let dt = time_col.datetime()?.get(i);
                    if let Some(datetime) = dt {
                        // Extract hour (0-23) from nanosecond timestamp
                        let hour = datetime / 3600000000000 % 24;
                        let minute = (datetime / 60000000000) % 60;
                        format!("{:02}:{:02}", hour, minute)
                    } else {
                        "".to_string()
                    }
                }
                _ => "".to_string(),
            };

            // Parse hour:minute
            let parts: Vec<&str> = time_str.split(':').collect();
            let hour: usize = parts.first().unwrap_or(&"0").parse().unwrap_or(0);
            let minute: usize = parts.get(1).unwrap_or(&"0").parse().unwrap_or(0);
            let time_value = hour * 60 + minute; // Convert to minutes since midnight

            // Check if we're in allowed trading sessions
            let morning_allowed = !params.filter_morning_session
                || (9 * 60 + 30..11 * 60).contains(&time_value);
            let lunch_allowed = !params.filter_lunch_session
                || !(11 * 60 + 30..13 * 60 + 30).contains(&time_value);
            let afternoon_allowed =
                !params.filter_afternoon_session || (14 * 60..16 * 60).contains(&time_value);

            morning_allowed && lunch_allowed && afternoon_allowed
        } else {
            true // If no time column, don't filter
        };

        // Volume confirmation
        let volume_confirmed =
            !params.use_volume_confirmation || vol_val >= avg_volume * params.volume_threshold;

        // Check for buy and sell conditions
        let buy_conditions = !is_in_position
            && is_allowed_time
            && volume_confirmed
            && price > ema_val
            && price > vwap_val
            && rsi_val > params.rsi_threshold
            && roc_val > params.roc_threshold
            && macd_val > macd_signal_val
            && prev_macd <= prev_macd_signal; // MACD crossover

        // Conditions to exit existing position
        let stop_hit = is_in_position && price <= current_stop;
        let target_hit = is_in_position && price >= current_target;
        let trend_reversal = is_in_position
            && (
                price < ema_val
                    || rsi_val < (100.0 - params.rsi_threshold)
                    || (macd_val < macd_signal_val && prev_macd >= prev_macd_signal)
                // MACD crossover down
            );

        let sell_conditions = stop_hit || target_hit || trend_reversal;

        // Generate signals
        let buy_signal = if buy_conditions { 1 } else { 0 };
        let sell_signal = if sell_conditions { 1 } else { 0 };

        // When buying, calculate stop loss and take profit levels
        if buy_signal == 1 {
            let stop_loss = price - (atr_val * params.atr_stop_multiplier);
            let take_profit = price + (atr_val * params.atr_profit_multiplier);

            // Update tracking variables
            current_stop = stop_loss;
            current_target = take_profit;

            stop_levels.push(stop_loss);
            target_levels.push(take_profit);
        } else {
            // Just push current values if not entering a new position
            stop_levels.push(current_stop);
            target_levels.push(current_target);
        }

        buy_signals.push(buy_signal);
        sell_signals.push(sell_signal);

        // Update position status
        if buy_signal == 1 {
            is_in_position = true;
        } else if sell_signal == 1 {
            is_in_position = false;
            current_stop = 0.0;
            current_target = 0.0;
        }
    }

    // Create a new DataFrame with all indicators
    let mut indicator_df = df.clone();

    // Add indicators to the DataFrame
    let _ = indicator_df.with_column(ema.with_name("ema".into()));
    let _ = indicator_df.with_column(vwap.with_name("vwap".into()));
    let _ = indicator_df.with_column(rsi.with_name("rsi".into()));
    let _ = indicator_df.with_column(roc.with_name("roc".into()));
    let _ = indicator_df.with_column(macd.with_name("macd".into()));
    let _ = indicator_df.with_column(macd_signal.with_name("macd_signal".into()));
    let _ = indicator_df.with_column(atr.with_name("atr".into()));
    let _ = indicator_df.with_column(bb_upper.with_name("bb_upper".into()));
    let _ = indicator_df.with_column(bb_lower.with_name("bb_lower".into()));

    // Add signals and levels
    let buy_series = Series::new("buy_signal".into(), &buy_signals);
    let sell_series = Series::new("sell_signal".into(), &sell_signals);
    let stop_series = Series::new("stop_loss".into(), &stop_levels);
    let target_series = Series::new("take_profit".into(), &target_levels);

    let _ = indicator_df.with_column(buy_series);
    let _ = indicator_df.with_column(sell_series);
    let _ = indicator_df.with_column(stop_series);
    let _ = indicator_df.with_column(target_series);

    Ok(StrategySignals {
        buy_signals,
        sell_signals,
        stop_levels,
        target_levels,
        indicator_values: indicator_df,
    })
}

/// Calculate performance metrics for the momentum-focused strategy with risk management
///
/// This function takes the buy/sell signals and stop/target levels generated
/// by the strategy and calculates various performance metrics, with special focus
/// on risk-adjusted returns and time-based performance analysis.
///
/// # Performance metrics calculated
///
/// - Final Value: The ending portfolio value
/// - Total Return: The percentage return compared to initial capital
/// - Number of Trades: Total number of completed trades
/// - Win Rate: Percentage of profitable trades
/// - Maximum Drawdown: The largest percentage drop from peak to trough
/// - Average Return per Trade: Mean return per completed trade
/// - Average Holding Time: Mean duration of trades in minutes
///
/// # Arguments
///
/// * `close_prices` - Column of close prices
/// * `buy_signals` - Vector of buy signals (0 or 1)
/// * `sell_signals` - Vector of sell signals (0 or 1)
/// * `stop_levels` - Vector of stop loss levels
/// * `target_levels` - Vector of take profit levels
/// * `start_capital` - Starting capital amount
/// * `include_last_day` - Whether to include partial results from the last trading day
///
/// # Returns
///
/// A tuple containing (final_value, total_return, num_trades, win_rate, max_drawdown, avg_return_per_trade, avg_holding_time)
pub fn calculate_performance(
    close_prices: &Column,
    buy_signals: &[i32],
    sell_signals: &[i32],
    stop_levels: &[f64],
    target_levels: &[f64],
    start_capital: f64,
    include_last_day: bool,
) -> (f64, f64, usize, f64, f64, f64, f64) {
    let close = close_prices.f64().unwrap();
    let mut capital = start_capital;
    let mut shares = 0.0;
    let mut trades = 0;
    let mut wins = 0;
    let mut _losses = 0;
    let mut buy_price = 0.0;
    let mut entry_time = 0;
    let mut _total_profit = 0.0;
    let mut _total_loss = 0.0;
    let mut total_trade_duration = 0;
    let mut equity_curve = Vec::with_capacity(close.len());
    let mut max_equity = start_capital;
    let mut max_drawdown = 0.0;
    let mut trade_returns = Vec::new();

    // Track the current day to handle end-of-day reporting
    let mut _current_day = 0;

    // Determine starting point with valid signals
    let start_idx = buy_signals
        .iter()
        .position(|&x| x == 1)
        .unwrap_or(0)
        .saturating_sub(1);

    // Initialize equity curve
    for _ in 0..close.len() {
        equity_curve.push(start_capital);
    }

    // Process signals
    for i in start_idx..close.len() {
        let price = close.get(i).unwrap_or(0.0);
        let buy_signal = buy_signals[i];
        let sell_signal = sell_signals[i];
        let stop_level = stop_levels[i];
        let target_level = target_levels[i];

        // Check if price hit stop loss or take profit
        let hit_stop = shares > 0.0 && price <= stop_level && stop_level > 0.0;
        let hit_target = shares > 0.0 && price >= target_level && target_level > 0.0;

        // Day tracking (simplified - in practice you'd use the time/date column)
        let day = i / 390; // Assuming 390 minutes in a trading day (6.5 hours)
        let is_last_day = day == (close.len() - 1) / 390;

        // Skip if it's the last day and we don't want to include partial results
        if is_last_day && !include_last_day {
            break;
        }

        // Check for automatic exit signals
        let auto_exit = hit_stop || hit_target;

        // Entry signal
        if buy_signal == 1 && shares == 0.0 {
            shares = capital / price;
            capital = 0.0;
            buy_price = price;
            entry_time = i;
            trades += 1;
        }
        // Exit signal (either explicit sell or automatic stop/target)
        else if (sell_signal == 1 || auto_exit) && shares > 0.0 {
            capital = shares * price;
            let trade_profit = capital - (shares * buy_price);
            let trade_return = (price / buy_price - 1.0) * 100.0;
            let trade_duration = i - entry_time;

            // Record success/failure and profit/loss
            if trade_profit > 0.0 {
                wins += 1;
                _total_profit += trade_profit;
            } else {
                _losses += 1;
                _total_loss += trade_profit.abs();
            }

            total_trade_duration += trade_duration;
            trade_returns.push(trade_return);
            shares = 0.0;

            // Note the reason for exit for detailed reporting
            let _exit_reason = if hit_stop {
                "Stop Loss"
            } else if hit_target {
                "Take Profit"
            } else {
                "Sell Signal"
            };
        }

        // Update equity curve
        let current_equity = capital + (shares * price);
        equity_curve[i] = current_equity;

        // Update max equity and drawdown
        if current_equity > max_equity {
            max_equity = current_equity;
        } else {
            let drawdown = (max_equity - current_equity) / max_equity;
            if drawdown > max_drawdown {
                max_drawdown = drawdown;
            }
        }

        _current_day = day;
    }

    // Close any open position at the end of the backtest
    if shares > 0.0 {
        let final_price = close.get(close.len() - 1).unwrap_or(0.0);
        capital = shares * final_price;
    }

    // Final calculations
    let final_value = capital;
    let total_return = (final_value / start_capital - 1.0) * 100.0;
    let win_rate = if trades > 0 {
        (wins as f64 / trades as f64) * 100.0
    } else {
        0.0
    };
    let avg_return_per_trade = if !trade_returns.is_empty() {
        trade_returns.iter().sum::<f64>() / trade_returns.len() as f64
    } else {
        0.0
    };
    let avg_holding_time = if trades > 0 {
        total_trade_duration as f64 / trades as f64
    } else {
        0.0
    };

    (
        final_value,
        total_return,
        trades,
        win_rate,
        max_drawdown,
        avg_return_per_trade,
        avg_holding_time,
    )
}
